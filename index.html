<!DOCTYPE html>
<html lang="en">
<head>
  <title>GRAVITY SIMULATION</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="description" content="HTML5 website template">
  <meta name="keywords" content="global, template, html, sass, jquery">
  <meta name="author" content="Bucky Maler">
  <link rel="stylesheet" href="assets/css/main.css">
</head>
<body>

<div class="perspective effect-rotate-left">
  <div class="container"><div class="outer-nav--return"></div>
    <div id="viewport" class="l-viewport">
      <div class="l-wrapper">
        <header class="header">
          <div class="header--nav-toggle">
            <span></span>
          </div>
        </header>
        <nav class="l-side-nav">
          <ul class="side-nav">
            <li class="is-active"><span>Home</span></li>
            <li><span>Works</span></li>
            <li><span>About</span></li>
          </ul>
        </nav>
        <ul class="l-main-content main-content">
          <li class="l-section section section--is-active">
            <div class="intro">
              <div class="intro--banner">
                <h1>ROCKET<br>LAUNCH<br>SIMULATION</h1>
                <img src="assets/img/introduction-visual.png" alt="Welcome">
              </div>
              <div class="intro--options">
                <a href="#0">
                  <h3>vis viva equation</h3>
                  <p>다른 물체를 공전하는 어떤 물체의 속도를 궤도의 긴반지름과 초점으로부터 물체까지의 거리로 나타내는 방정식</p>
                </a>
                <a href="#0">
                  <h3>harmonic law</h3>
                  <p>행성의 공전 주기의 제곱은 공전 궤도 장반경의 세제곱에 비례함을 의미하는 케플러 3법칙</p>
                </a>
                <a href="#0">
                  <h3>Three.JS</h3>
                  <p>WebGL기반 JS 렌더링 라이브러리</p>
                </a>
              </div>
            </div>
          </li>
          <li class="l-section section" id="move">
            <div class="about">
            <div>
              <input id="kms" type='number' min='-30' max='30' step='0.1' style="color: black; width: 100px;"  placeholder="속도[km/s]">
              <input id="degree" type='number' min='-90' max='90' step='0.1' style="color: black; width: 100px;" placeholder="각도[°]">
            </div>
              <canvas id="canvas" width="960" height="640"></canvas>
              <button id="btn1" style="color: black;">start</button>
            </div>
          </li>
          <li class="l-section section">
            <div class="contact">
              <div class="contact--lockup">
                <div class="modal">
                  <div class="modal--information">
                    <a href="mailto:ouremail@gmail.com">soysaucecrab</a>
                  </div>
                  <ul class="modal--options">
                    <li><a href="https://school.gyo6.net/gsshs/main.do?sysId=gsshs" target="_blank">School</a></li>
                    <li><a href="https://github.com/soysaucecrab/minimini-project-main" target="_blank">Github</a></li>
                    <li><a href="mailto:kimzinu07@gmail.com">Contact Me</a></li>
                  </ul>
                </div>
              </div>
            </div>
          </li>
        </ul>
      </div>
    </div>
  </div>
  <ul class="outer-nav">
    <li class="is-active">Home</li>
    <li>Works</li>
    <li>About</li>
  </ul>
</div>
<script src="examples/deps/three/build/three.min.js"></script>
<script src="examples/deps/three/examples/js/controls/OrbitControls.js"></script>
<script src="examples/deps/three/examples/js/libs/stats.min.js"></script>

<script type="module">
  (async () => {
      /* init */

      const canvas = document.getElementById("canvas");
      const camera = new THREE.PerspectiveCamera(75, canvas.width/canvas.height, 0.1, 1000);

      const renderer = new THREE.WebGLRenderer({ canvas });
      const controls = new THREE.OrbitControls(camera, renderer.domElement);

      const scene = new THREE.Scene();

      camera.position.set(0,25,0);
      camera.lookAt(0, 0, 0);
      
      const gridHelper = new THREE.GridHelper(100, 100);
      scene.add(gridHelper);
      const render = () => {
          renderer.render(scene, camera);
      };

      controls.addEventListener('change', render);

      // 별 객체 정의
      class Star {
          constructor(mass, position, velocity,color,size) {
              this.mass = mass;
              this.position = position;
              this.velocity = velocity;

              const sphereGeometry = new THREE.SphereGeometry(size);
              const sphereMaterial = new THREE.MeshBasicMaterial({ color: color });
              this.sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
              this.sphere.position.set(position[0],position[1],position[2]);
              scene.add(this.sphere); 
          }
          posit(){
              this.sphere.position.set(this.position[0],this.position[1],this.position[2]);
          }
      }

      const dt = 1e5; // 시간 단계 (초)
      // 중력 상수
      const G = 6.67430e-11; // 단위: m^3 kg^-1 s^-2
      const AU = 1.496e11; //AU천문단위 * 1000 -> m
      const initEarthSpeed = 30; // 초기 속도 (km/s)
      const initMarsSpeed = 23.86; // 초기 속도 (km/s)

      var kms = 2.95;
      var inputAngle =44.6 ;

      // 태양, 지구, 화성 객체 생성
      const star1 = new Star(1.989e30, [0, 0, 0], [0, 0, 0],0xff7f00,0.4); 
      const star2 = new Star(5.972e24, [0,0,9.83], [initEarthSpeed/AU*10000, 0, 0],0x3fe87f,0.2);
      const star3 = new Star(6.39e23, [0,0,15.2], [initMarsSpeed/AU*10000, 0, 0],0xfe4266,0.17);



      // 중력에 의한 가속도 계산 (3차원)
      function calculateAcceleration(star1, star2) {
          const dx = star2.position[0] - star1.position[0];
          const dy = star2.position[1] - star1.position[1];
          const dz = star2.position[2] - star1.position[2];
          const distanceSquared = dx * dx + dy * dy + dz * dz;
          const distance = Math.sqrt(distanceSquared);
          const forceMagnitude = ((G * star1.mass * star2.mass) / (distanceSquared * AU*AU)) *100;
          const ax = forceMagnitude * (dx / distance ) / star1.mass;
          const ay = forceMagnitude * (dy / distance ) / star1.mass;
          const az = forceMagnitude * (dz / distance ) / star1.mass;
          return [ax, ay, az];
      }

      // 각 별의 위치 업데이트 (3차원)
      function updatePositions(star1, star2, dt) {
          const [ax1, ay1, az1] = calculateAcceleration(star1, star2);
          const [ax2, ay2, az2] = calculateAcceleration(star2, star1);
          star1.velocity[0] += ax1 * dt/ AU*10;
          star1.velocity[1] += ay1 * dt/ AU*10;
          star1.velocity[2] += az1 * dt/ AU*10;
          star2.velocity[0] += ax2 * dt/ AU*10;
          star2.velocity[1] += ay2 * dt/ AU*10;
          star2.velocity[2] += az2 * dt/ AU*10;
          star1.position[0] += star1.velocity[0] * dt;
          star1.position[1] += star1.velocity[1] * dt;
          star1.position[2] += star1.velocity[2] * dt;
          star2.position[0] += star2.velocity[0] * dt;
          star2.position[1] += star2.velocity[1] * dt;
          star2.position[2] += star2.velocity[2] * dt;
      }

      var previousAngle;
      var currentAngle;

      var satellite = new Star(1e-5, [0,0,1e10], [0,0,0],0xffffff, 0.1);

      function calculateAngle(){
          previousAngle = currentAngle;

          // 위치 벡터
          const vector1 = new THREE.Vector3().fromArray(star1.position);
          const vector2 = new THREE.Vector3().fromArray(star2.position);
          const vector3 = new THREE.Vector3().fromArray(star3.position);

          // star2에서 star1로 향하는 벡터와 star2에서 star3으로 향하는 벡터를 구합니다.
          const vector21 = vector2.clone().sub(vector1);
          const vector31 = vector3.clone().sub(vector1);

          // 두 벡터 사이 각 계산
          const angle = vector21.angleTo(vector31); // 라디안 단위로 반환됩니다.

          // 각도변환
          const angleDegrees = THREE.MathUtils.radToDeg(angle);
          currentAngle = angleDegrees;

          if((previousAngle>inputAngle)&&(currentAngle<inputAngle)){
              // star2 : 접선 방향 벡터
              var tangentDirection = new THREE.Vector3(Math.sin(40 * Math.PI / 180), 0, Math.cos(40 * Math.PI / 180)).normalize();

              // 초기위치 설정
              const position = new THREE.Vector3().fromArray(star2.position);
              var sattelliteInitialPosition = position.clone();

              const satelliteInitialSpeed = tangentDirection.clone().multiplyScalar(kms/AU*10000);

              // sattellite 선언
              satellite = new Star(1e3, sattelliteInitialPosition.toArray(), [star2.velocity[0]+star2.velocity[0]*kms/30,star2.velocity[1]+star2.velocity[1]*kms/30,star2.velocity[2]+star2.velocity[2]*kms/30],0xffffff,0.1);
              return;
          }
          return angleDegrees;
      }

      function calculateDistance(point1, point2) {
          const dx = point2[0] - point1[0];
          const dy = point2[1] - point1[1];
          const dz = point2[2] - point1[2];
          return Math.sqrt(dx * dx + dy * dy + dz * dz);
      }

      // 시뮬레이션 실행
      
      const numSteps = 10000; // 시뮬레이션 단계 수

      function calculate() {
          calculateAngle();

          updatePositions(star1, star2, dt);
          updatePositions(star1, star3, dt);
          updatePositions(star1, satellite, dt);
          
          // 충돌 감지 로직
          if (calculateDistance(star1.position, star2.position) < 0.2 ||
              calculateDistance(star1.position, star3.position) < 0.2 ||
              calculateDistance(star2.position, star3.position) < 0.2) {
              console.log("Collision detected");
              return;
          }

          if(calculateDistance(star3.position, satellite.position) < 0.2){
            
            return;
          }
          
          star1.posit();
          star2.posit();
          star3.posit();
          satellite.posit();
          
          render(); // 렌더 함수 호출
          i++;
          if (i < numSteps) {
              setTimeout(calculate, 10); // 1초 후에 다음 단계를 계산하도록 호출
          }
      }
      render();
      let i = 0;
      var act=true;

      document.getElementById("btn1").addEventListener('click',cal);

      function cal(){
       if(act){
          act=false;
          kms = parseFloat(document.getElementById('kms').value);
          inputAngle = parseFloat(document.getElementById('degree').value);
          if(!kms){
            kms=2.95;
          }
          if(!inputAngle){
            inputAngle = 44.6;
          }
          calculate();
       }
       else{
        location.reload();
       }
      }

  })(); 
</script>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.2.4/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="assets/js/vendor/jquery-2.2.4.min.js"><\/script>')</script>
<script src="assets/js/functions-min.js"></script>
</body>
</html>
