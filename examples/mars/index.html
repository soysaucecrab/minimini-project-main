<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-type" content="text/html; charset=utf-8"/>
    <title>real_data</title>
</head>
<body>
    <canvas id="canvas" width="960" height="640"></canvas>

    <script src="../deps/three/build/three.min.js"></script>
    <script src="../deps/three/examples/js/controls/OrbitControls.js"></script>
    <script src="../deps/three/examples/js/libs/stats.min.js"></script>

    <script type="module">
    (async () => {
        /* init */

        const canvas = document.getElementById("canvas");
        const camera = new THREE.PerspectiveCamera(75, canvas.width/canvas.height, 0.1, 1000);

        const renderer = new THREE.WebGLRenderer({ canvas });
        const controls = new THREE.OrbitControls(camera, renderer.domElement);

        const scene = new THREE.Scene();

        camera.position.set(0,25,0);
        camera.lookAt(0, 0, 0);
        
        const gridHelper = new THREE.GridHelper(100, 100);
        scene.add(gridHelper);
        const render = () => {
            renderer.render(scene, camera);
        };

        controls.addEventListener('change', render);

        
        
        

        // 별 객체 정의
        class Star {
            constructor(mass, position, velocity) {
                this.mass = mass;
                this.position = position;
                this.velocity = velocity;

                const sphereGeometry = new THREE.SphereGeometry(0.1);
                const sphereMaterial = new THREE.MeshBasicMaterial({ color: 0xffff66 });
                this.sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                this.sphere.position.set(position[0],position[1],position[2]);
                scene.add(this.sphere); 
            }
            posit(){
                this.sphere.position.set(this.position[0],this.position[1],this.position[2]);
            }
        }

        const dt = 1e5; // 시간 단계 (초)
        // 중력 상수
        const G = 6.67430e-11; // 단위: m^3 kg^-1 s^-2
        const AU = 1.496e11; //AU천문단위 * 1000 -> m
        const initEarthSpeed = 30; // 초기 속도 (km/s)
        const initMarsSpeed = 23.86; // 초기 속도 (km/s)

        var kms = 2.95;

        // 태양, 지구, 화성 객체 생성
        const star1 = new Star(1.989e30, [0, 0, 0], [0, 0, 0]); 
        const star2 = new Star(5.972e24, [0,0,9.83], [initEarthSpeed/AU*10000, 0, 0]);
        const star3 = new Star(6.39e23, [0,0,15.2], [initMarsSpeed/AU*10000, 0, 0]);


        // 중력에 의한 가속도 계산 (3차원)
        function calculateAcceleration(star1, star2) {
            const dx = star2.position[0] - star1.position[0];
            const dy = star2.position[1] - star1.position[1];
            const dz = star2.position[2] - star1.position[2];
            const distanceSquared = dx * dx + dy * dy + dz * dz;
            const distance = Math.sqrt(distanceSquared);
            const forceMagnitude = ((G * star1.mass * star2.mass) / (distanceSquared * AU*AU)) *100;
            const ax = forceMagnitude * (dx / distance ) / star1.mass;
            const ay = forceMagnitude * (dy / distance ) / star1.mass;
            const az = forceMagnitude * (dz / distance ) / star1.mass;
            return [ax, ay, az];
        }

        // 각 별의 위치 업데이트 (3차원)
        function updatePositions(star1, star2, dt) {
            const [ax1, ay1, az1] = calculateAcceleration(star1, star2);
            const [ax2, ay2, az2] = calculateAcceleration(star2, star1);
            star1.velocity[0] += ax1 * dt/ AU*10;
            star1.velocity[1] += ay1 * dt/ AU*10;
            star1.velocity[2] += az1 * dt/ AU*10;
            star2.velocity[0] += ax2 * dt/ AU*10;
            star2.velocity[1] += ay2 * dt/ AU*10;
            star2.velocity[2] += az2 * dt/ AU*10;
            star1.position[0] += star1.velocity[0] * dt;
            star1.position[1] += star1.velocity[1] * dt;
            star1.position[2] += star1.velocity[2] * dt;
            star2.position[0] += star2.velocity[0] * dt;
            star2.position[1] += star2.velocity[1] * dt;
            star2.position[2] += star2.velocity[2] * dt;
        }

        var previousAngle;
        var currentAngle;

        var satellite = new Star(1e-5, [0,0,1e10], [0,0,0]);

        function calculateAngle(){
            previousAngle = currentAngle;

            // 위치 벡터
            const vector1 = new THREE.Vector3().fromArray(star1.position);
            const vector2 = new THREE.Vector3().fromArray(star2.position);
            const vector3 = new THREE.Vector3().fromArray(star3.position);

            // star2에서 star1로 향하는 벡터와 star2에서 star3으로 향하는 벡터를 구합니다.
            const vector21 = vector2.clone().sub(vector1);
            const vector31 = vector3.clone().sub(vector1);

            // 두 벡터 사이 각 계산
            const angle = vector21.angleTo(vector31); // 라디안 단위로 반환됩니다.

            // 각도변환
            const angleDegrees = THREE.MathUtils.radToDeg(angle);
            currentAngle = angleDegrees;

            if((previousAngle>44.6)&&(currentAngle<44.6)){
                // star2 : 접선 방향 벡터
                var tangentDirection = new THREE.Vector3(Math.sin(40 * Math.PI / 180), 0, Math.cos(40 * Math.PI / 180)).normalize();

                // 초기위치 설정
                const position = new THREE.Vector3().fromArray(star2.position);
                var sattelliteInitialPosition = position.clone();

                const satelliteInitialSpeed = tangentDirection.clone().multiplyScalar(kms/AU*10000);

                // sattellite 선언
                satellite = new Star(1e3, sattelliteInitialPosition.toArray(), [star2.velocity[0]+star2.velocity[0]*kms/30,star2.velocity[1]+star2.velocity[1]*kms/30,star2.velocity[2]+star2.velocity[2]*kms/30]);
                alert("발사됨!");
            }
            return angleDegrees;
        }

        function calculateDistance(point1, point2) {
            const dx = point2[0] - point1[0];
            const dy = point2[1] - point1[1];
            const dz = point2[2] - point1[2];
            return Math.sqrt(dx * dx + dy * dy + dz * dz);
        }

        // 시뮬레이션 실행
       
        const numSteps = 10000; // 시뮬레이션 단계 수

        function calculate() {
            calculateAngle();

            updatePositions(star1, star2, dt);
            updatePositions(star1, star3, dt);
            updatePositions(star1, satellite, dt);
            
            // 충돌 감지 로직
            if (calculateDistance(star1.position, star2.position) < 0.2 ||
                calculateDistance(star1.position, star3.position) < 0.2 ||
                calculateDistance(star2.position, star3.position) < 0.2) {
                console.log("Collision detected");
                return;
            }

            if(calculateDistance(star3.position, satellite.position) < 0.2){
                alert("successful landed");
                location.reload(true); 
            }
            
            star1.posit();
            star2.posit();
            star3.posit();
            satellite.posit();
            
            render(); // 렌더 함수 호출
            i++;
            if (i < numSteps) {
                setTimeout(calculate, 10); // 1초 후에 다음 단계를 계산하도록 호출
            }
        }

        let i = 0;
        calculate(); // 첫 번째 계산 시작


    })();
    </script>
</body>
</html>
